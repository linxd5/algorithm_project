## 1. 大作业内容

用下列几种方法解决 0-1 背包问题，编程实现并对比各算法的`求解质量`和`复杂度`：

- 贪婪算法
- 动态规划
- 分支限界或回溯
- 模拟退火或遗传算法（随机算法运行 30 run）

自己生成 0-1 背包问题，问题规模 500-1000，物体重量范围 1-100，价值范围 1-100，重量和价值可以相关，也可以无关。背包容量可以设置为物体总重量的二分之一，三分之二等不同松紧度。（`generate_data.py`）

课程结束后提交实验报告（含问题定义，算法过程，结果对比和分析，算法过程截图等）和源程序。

求解质量应该是看各算法给出的总价值的大小。

### 2. 实验报告

C++ 的坑太大了：

- `map<int, float>` 不支持按照 value 的大小进行排序，需要转换为 `vector<pair<int, float>>`，然后才能进行排序。


- 往 `vector<pair<int, float> >` 中插入` pair<int, float>` 的时候，还需要先声明一个 `pair<int, float>`类型的变量，往这个变量中装入数据，然后在插入到 `vector<pair<int, float> >` 中。


这些过程都是十分繁琐无用的，因此建议弃坑转 python，使用 python 快速地迭代开发。如果后面真的想学习 C++ 的相关知识，或者提高所谓的性能的话，可以再从 python 转到 C++。


见同目录下的 `README.pdf`
